import { Clock, Activity, Zap, Info } from 'lucide-react';

declare const chrome: any;

interface Settings {
  isActive: boolean;
  latencyMonitorEnabled: boolean;
  warningThreshold: number;
  criticalThreshold: number;
  featureTwoEnabled: boolean;
  autoCheckEnabled: boolean;
  offsetButtonsEnabled: boolean;
  customOffsets: string;
  limitAdjusterEnabled: boolean;
  confirmPageEnabled: boolean;
}

let settings: Settings = {
  isActive: true,
  latencyMonitorEnabled: true,
  warningThreshold: 5,
  criticalThreshold: 20,
  featureTwoEnabled: false,
  autoCheckEnabled: false,
  offsetButtonsEnabled: false,
  customOffsets: '0.1, 0.5, 1.0',
  limitAdjusterEnabled: false,
  confirmPageEnabled: false,
};

// Load settings on startup
if (typeof chrome !== 'undefined' && chrome.storage) {
  chrome.storage.sync.get(['latencySettings'], (result: any) => {
    if (result.latencySettings) {
      const loaded = result.latencySettings;
      if (typeof loaded.isActive !== 'undefined' && typeof loaded.latencyMonitorEnabled === 'undefined') {
        loaded.latencyMonitorEnabled = loaded.isActive;
      }
      settings = { ...settings, ...loaded };
    }
  });

  chrome.storage.onChanged.addListener((changes: any, namespace: string) => {
    if (namespace === 'sync' && changes.latencySettings) {
      settings = changes.latencySettings.newValue;
      updateUIState();
      processTimestamps();
    }
  });
}

// --- Helper Functions ---

const parseTime = (timeStr: string): Date | null => {
  const timeRegex = /(\d{1,2}):(\d{2}):(\d{2})/;
  const match = timeStr.match(timeRegex);

  if (!match) return null;

  const now = new Date();
  const date = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  date.setHours(parseInt(match[1], 10));
  date.setMinutes(parseInt(match[2], 10));
  date.setSeconds(parseInt(match[3], 10));

  if (date.getTime() > now.getTime() + 60000) {
    date.setDate(date.getDate() - 1);
  }

  return date;
};

const updatePerformanceIndicator = (latencyData: { stateClass: string, displayTime: string }) => {
  const primaryTextNodes = document.querySelectorAll('.text-color-primary');
  let targetLabel: Element | null = null;

  for (let i = 0; i < primaryTextNodes.length; i++) {
    if (primaryTextNodes[i].textContent?.includes('Wertentwicklung seit Kauf')) {
      targetLabel = primaryTextNodes[i];
      break;
    }
  }

  if (!targetLabel || !targetLabel.parentElement) return;

  const valueContainer = targetLabel.parentElement.querySelector('.font-medium');

  if (valueContainer) {
    let indicator = valueContainer.querySelector('.latency-extra-indicator') as HTMLElement;

    if (!indicator) {
      indicator = document.createElement('span');
      indicator.className = 'latency-indicator latency-extra-indicator';
      indicator.style.marginLeft = '10px';
      valueContainer.appendChild(indicator);
    }

    indicator.classList.remove('latency-good', 'latency-warning', 'latency-critical');
    indicator.classList.add(latencyData.stateClass);
    indicator.innerText = latencyData.displayTime;
  }
};

const removeAllIndicators = () => {
  document.querySelectorAll('.latency-indicator').forEach((el) => el.remove());
};

const injectStyles = () => {
  if (document.getElementById('zero-delay-styles')) return;
  const style = document.createElement('style');
  style.id = 'zero-delay-styles';
  style.textContent = `
    .zd-btn {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      border: 1px solid #ced4da;
      cursor: pointer;
      font-weight: 500;
      line-height: 1.4;
      transition: all 0.2s;
      background-color: #fff;
      color: #495057;
    }
    .zd-btn:hover {
      background-color: #e9ecef;
      border-color: #adb5bd;
    }
    .zd-btn-primary {
      border-color: #248eff;
      background-color: #248eff;
      color: #fff;
    }
    .zd-btn-primary:hover {
      background-color: #1a75d6;
      border-color: #1a75d6;
    }
    .zd-offset-btn {
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 3px;
      min-width: 35px;
      text-align: center;
      line-height: 1.2;
    }
    .zd-group-col {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: stretch;
    }
    .zd-offsets-row {
      display: flex;
      gap: 2px;
      justify-content: space-between;
    }
    .zd-offsets-row .zd-btn {
      flex: 1;
    }
    .zd-separator {
      color: #6c757d;
      font-weight: bold;
      font-size: 12px;
      align-self: center;
      margin: 0 4px;
    }
    .zd-limit-adjuster {
      display: flex;
      justify-content: flex-start;
      gap: 4px;
    }
    .latency-indicator {
      font-size: 0.75em;
      font-weight: bold;
      padding: 2px 4px;
      border-radius: 3px;
      margin-left: 5px;
      white-space: nowrap;
    }
    .latency-good {
      color: #198754;
      background-color: #d1e7dd;
    }
    .latency-warning {
      color: #ffc107;
      background-color: #fff3cd;
    }
    .latency-critical {
      color: #dc3545;
      background-color: #f8d7da;
    }
    .zd-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 10000;
      white-space: nowrap;
      transform: translateX(-50%);
    }
  `;
  document.head.appendChild(style);
};

let lastState = {
  bid: '',
  ask: '',
  single: '',
  autoCheck: false,
  offsetEnabled: false,
  offsets: ''
};

let isShiftHeld = false;

const updateUIState = () => {
  // Skip shift logic on confirm page
  const isConfirmPage = !!document.querySelector('trade-confirm');
  const isCheckMode = isConfirmPage ? false : (settings.autoCheckEnabled || isShiftHeld);

  // Update main buttons
  document.querySelectorAll('.zd-btn').forEach(btn => {
    if (btn.classList.contains('zd-offset-btn') && btn.parentElement?.classList.contains('zd-limit-adjuster')) return;
    // Skip confirm page buttons
    if (btn.closest('.zero-delay-confirm-controls')) return;

    const originalText = btn.getAttribute('data-original-text') || btn.textContent?.replace(' & Prüfen', '') || '';
    if (!btn.getAttribute('data-original-text')) {
      btn.setAttribute('data-original-text', originalText);
    }

    if (isCheckMode) {
      btn.classList.add('zd-btn-primary');
      if (!btn.textContent?.includes('& Prüfen') && !btn.classList.contains('zd-offset-btn')) {
        btn.textContent = `${originalText} & Prüfen`;
      }
    } else {
      btn.classList.remove('zd-btn-primary');
      if (!btn.classList.contains('zd-offset-btn')) {
        btn.textContent = originalText;
      }
    }
  });

  // Update Limit Adjuster visibility (not on confirm page)
  if (!isConfirmPage) {
    const adjusters = document.querySelectorAll('.zd-limit-adjuster');
    adjusters.forEach(el => {
      (el as HTMLElement).style.display = isCheckMode ? 'none' : 'flex';
    });
  }
};

document.addEventListener('keydown', (e) => {
  if (e.key === 'Shift' && !isShiftHeld) {
    isShiftHeld = true;
    updateUIState();
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'Shift') {
    isShiftHeld = false;
    updateUIState();
  }
});

const setLimitValue = (priceStr: string, autoCheck: boolean) => {
  const limitButton = document.querySelector('div[data-zid="limit-order"]') as HTMLElement;
  const limitInputSelector = 'input[data-zid="limit-order-input"]';

  if (!limitButton) {
    console.warn('ZeroDelay: Limit button not found');
    return;
  }

  let input = document.querySelector(limitInputSelector) as HTMLInputElement;

  if (!input) {
    limitButton.click();
  }

  let attempts = 0;
  const maxAttempts = 20;

  const interval = setInterval(() => {
    attempts++;
    input = document.querySelector(limitInputSelector) as HTMLInputElement;

    if (input) {
      clearInterval(interval);

      input.value = priceStr;
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      input.dispatchEvent(new Event('blur', { bubbles: true }));

      if (autoCheck) {
        setTimeout(() => {
          const checkButton = document.querySelector('web-design-system-button[data-zid="check-order"] button') as HTMLElement;
          if (checkButton) {
            checkButton.click();
          } else {
            console.warn('ZeroDelay: Check Order button not found');
          }
        }, 200);
      }

    } else if (attempts >= maxAttempts) {
      clearInterval(interval);
      console.warn('ZeroDelay: Limit input did not appear');
    }
  }, 50);
};

// --- Main Feature Functions ---

const injectLimitAdjuster = () => {
  if (!settings.limitAdjusterEnabled) {
    document.querySelectorAll('.zd-limit-adjuster').forEach(el => el.remove());
    return;
  }

  const input = document.querySelector('input[data-zid="limit-order-input"]') as HTMLInputElement;
  if (!input) return;

  // Check if already exists
  if (input.parentElement?.querySelector('.zd-limit-adjuster')) {
    // Just update visibility in case it was hidden/shown incorrectly
    updateUIState();
    return;
  }

  const createRow = (values: number[], isPositive: boolean) => {
    const row = document.createElement('div');
    row.className = 'zd-limit-adjuster';
    row.style.marginBottom = isPositive ? '4px' : '0';
    row.style.marginTop = isPositive ? '0' : '4px';

    values.forEach(val => {
      const btn = document.createElement('button');
      const sign = isPositive ? '+' : '-';
      btn.textContent = `${sign}${val.toString().replace('.', ',')}`;
      btn.className = 'zd-btn zd-offset-btn';
      btn.style.minWidth = '30px';

      btn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();

        let currentValStr = input.value.replace(',', '.');
        let currentVal = parseFloat(currentValStr);
        if (isNaN(currentVal)) currentVal = 0;

        const adjustment = isPositive ? val : -val;
        let newVal = currentVal + adjustment;
        if (newVal < 0) newVal = 0;

        const currentDecimals = currentValStr.includes('.') ? currentValStr.split('.')[1].length : 2;
        const valDecimals = val.toString().split('.')[1]?.length || 0;
        const finalDecimals = Math.max(currentDecimals, valDecimals);

        input.value = newVal.toFixed(finalDecimals);

        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      };
      row.appendChild(btn);
    });
    return row;
  };

  const values = [10, 1, 0.1, 0.01, 0.001];

  const topRow = createRow(values, true);
  input.insertAdjacentElement('beforebegin', topRow);

  const bottomRow = createRow(values, false);
  input.insertAdjacentElement('afterend', bottomRow);
};

// Helper to wait for element to appear in DOM
const waitForElement = (selector: string, timeout: number): Promise<Element | null> => {
  return new Promise((resolve) => {
    const element = document.querySelector(selector);
    if (element) {
      resolve(element);
      return;
    }

    const observer = new MutationObserver(() => {
      const el = document.querySelector(selector);
      if (el) {
        observer.disconnect();
        resolve(el);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    setTimeout(() => {
      observer.disconnect();
      resolve(null);
    }, timeout);
  });
};

const injectLimitButtons = () => {
  injectStyles();

  const container = document.querySelector('trade-create-quote') || document.querySelector('div[data-zid="quote-container"]');
  if (!container) return;

  if (!settings.featureTwoEnabled) {
    container.querySelector('.zero-delay-limit-controls')?.remove();
    return;
  }

  const limitButton = document.querySelector('div[data-zid="limit-order"]');
  if (!limitButton) {
    container.querySelector('.zero-delay-limit-controls')?.remove();
    return;
  }

  const bidNode = container.querySelector('span[data-zid="quote-spread"]');
  const askNode = container.querySelector('.quoteindicator');
  const singleNode = container.querySelector('span[data-zid="quote-sell"]');

  if ((!bidNode || !askNode) && !singleNode) return;

  const extractPrice = (text: string): string | null => {
    const match = text.match(/([\d,]+)/);
    if (!match) return null;
    return match[1].replace(',', '.');
  };

  let bidPriceStr: string | null = null;
  let askPriceStr: string | null = null;
  let singlePriceStr: string | null = null;

  if (bidNode && askNode) {
    bidPriceStr = extractPrice(bidNode.textContent || '');
    askPriceStr = extractPrice(askNode.textContent || '');
  } else if (singleNode) {
    singlePriceStr = extractPrice(singleNode.textContent || '');
  }

  const currentState = {
    bid: bidPriceStr || '',
    ask: askPriceStr || '',
    single: singlePriceStr || '',
    autoCheck: settings.autoCheckEnabled,
    offsetEnabled: settings.offsetButtonsEnabled,
    offsets: settings.customOffsets
  };

  if (
    currentState.bid === lastState.bid &&
    currentState.ask === lastState.ask &&
    currentState.single === lastState.single &&
    currentState.autoCheck === lastState.autoCheck &&
    currentState.offsetEnabled === lastState.offsetEnabled &&
    currentState.offsets === lastState.offsets &&
    container.querySelector('.zero-delay-limit-controls')
  ) {
    return;
  }

  lastState = currentState;

  // Cleanup old containers if they exist
  container.querySelector('.zero-delay-offset-controls')?.remove();

  let controls = container.querySelector('.zero-delay-limit-controls') as HTMLElement;
  if (!controls) {
    controls = document.createElement('div');
    controls.className = 'zero-delay-limit-controls d-flex justify-content-end align-items-start mt-0 mb-2';
    controls.style.gap = '8px';

    const quoteContainer = container.querySelector('div[data-zid="quote-container"]');
    if (quoteContainer) {
      quoteContainer.insertAdjacentElement('afterend', controls);
    } else {
      container.appendChild(controls);
    }
  } else {
    controls.innerHTML = '';
    controls.className = 'zero-delay-limit-controls d-flex justify-content-end align-items-start mt-0 mb-2';
    controls.style.gap = '8px';
  }

  const isAutoCheck = settings.autoCheckEnabled;
  let originalValue = '';

  const handleTooltip = (btn: HTMLButtonElement, priceStr: string) => {
    btn.onmouseenter = () => {
      let tooltip = document.getElementById('zd-tooltip-el');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'zd-tooltip-el';
        tooltip.className = 'zd-tooltip';
        document.body.appendChild(tooltip);
      }

      // Format price with dimmed extra decimals
      const formattedPrice = priceStr.replace('.', ',');
      const parts = formattedPrice.split(',');

      if (parts.length === 2 && parts[1].length > 2) {
        // Has more than 2 decimal places - dim the extras
        const mainPart = parts[0];
        const firstTwoDecimals = parts[1].substring(0, 2);
        const extraDecimals = parts[1].substring(2);
        tooltip.innerHTML = `${mainPart},${firstTwoDecimals}<span style="opacity: 0.5;">${extraDecimals}</span>`;
      } else {
        tooltip.textContent = formattedPrice;
      }

      tooltip.style.display = 'block';
    };

    btn.onmousemove = (e) => {
      const tooltip = document.getElementById('zd-tooltip-el');
      if (tooltip) {
        tooltip.style.top = `${e.clientY - 45}px`;
        tooltip.style.left = `${e.clientX}px`;
      }
    };

    btn.onmouseleave = () => {
      const tooltip = document.getElementById('zd-tooltip-el');
      if (tooltip) {
        tooltip.style.display = 'none';
      }
    };
  };

  const createBtn = (label: string, priceStr: string) => {
    const btn = document.createElement('button');
    btn.setAttribute('data-original-text', label);

    // Initial state
    if (isAutoCheck || isShiftHeld) {
      btn.textContent = `${label} & Prüfen`;
      btn.classList.add('zd-btn-primary');
    } else {
      btn.textContent = label;
    }

    btn.className = 'zd-btn';
    btn.style.width = '100%';

    handleTooltip(btn, priceStr);

    btn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();

      const tooltip = document.getElementById('zd-tooltip-el');
      if (tooltip) tooltip.style.display = 'none';

      btn.blur(); // Remove focus outline

      setLimitValue(priceStr, isAutoCheck || e.shiftKey);
    };
    return btn;
  };

  const getDecimals = (str: string) => {
    if (str.indexOf('.') < 0) return 2;
    return str.split('.')[1].length;
  };

  const createOffsetBtn = (basePriceStr: string, offset: number, isPositive: boolean) => {
    const basePrice = parseFloat(basePriceStr);
    const decimals = getDecimals(basePriceStr);
    const finalOffset = isPositive ? offset : -offset;
    const newPrice = basePrice * (1 + finalOffset / 100);
    const newPriceStr = newPrice.toFixed(decimals);

    const sign = isPositive ? '+' : '-';
    const label = `${sign}${offset.toString().replace('.', ',')}%`;

    const btn = document.createElement('button');
    btn.setAttribute('data-original-text', label);

    // Initial state
    if (isAutoCheck || isShiftHeld) {
      btn.classList.add('zd-btn-primary');
    }
    btn.textContent = label; // Offset buttons usually don't change text to "& Prüfen" due to space, but color changes

    btn.className = 'zd-btn zd-offset-btn';

    handleTooltip(btn, newPriceStr);

    btn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();

      const tooltip = document.getElementById('zd-tooltip-el');
      if (tooltip) tooltip.style.display = 'none';

      btn.blur(); // Remove focus outline

      setLimitValue(newPriceStr, isAutoCheck || e.shiftKey);
    };
    return btn;
  };

  const createPriceGroup = (label: string, priceStr: string) => {
    const group = document.createElement('div');
    group.className = 'zd-group-col';

    let offsets: number[] = [];
    if (settings.offsetButtonsEnabled && settings.customOffsets) {
      offsets = settings.customOffsets.split(';')
        .map(s => parseFloat(s.trim().replace(',', '.')))
        .filter(n => !isNaN(n));
      offsets = Array.from(new Set(offsets.map(Math.abs))).sort((a, b) => a - b);
    }

    // Top Row (Positive)
    if (offsets.length > 0) {
      const row = document.createElement('div');
      row.className = 'zd-offsets-row';
      offsets.forEach(off => {
        row.appendChild(createOffsetBtn(priceStr, off, true));
      });
      group.appendChild(row);
    }

    // Main Button
    group.appendChild(createBtn(label, priceStr));

    // Bottom Row (Negative)
    if (offsets.length > 0) {
      const row = document.createElement('div');
      row.className = 'zd-offsets-row';
      offsets.forEach(off => {
        row.appendChild(createOffsetBtn(priceStr, off, false));
      });
      group.appendChild(row);
    }

    return group;
  };

  if (bidPriceStr && askPriceStr) {
    const hasBid = !isNaN(parseFloat(bidPriceStr));
    const hasAsk = !isNaN(parseFloat(askPriceStr));

    if (hasBid) {
      controls.appendChild(createPriceGroup('Bid als Limit', bidPriceStr));
    }

    if (hasBid && hasAsk) {
      const separator = document.createElement('div');
      separator.textContent = '/';
      separator.className = 'zd-separator';
      controls.appendChild(separator);
    }

    if (hasAsk) {
      controls.appendChild(createPriceGroup('Ask als Limit', askPriceStr));
    }
  } else if (singlePriceStr) {
    const hasPrice = !isNaN(parseFloat(singlePriceStr));
    if (hasPrice) {
      controls.appendChild(createPriceGroup('Kurs als Limit', singlePriceStr));
    }
  }

  // Update UI state to ensure correct initial styling
  updateUIState();
};

const injectConfirmPageButtons = () => {
  const confirmPage = document.querySelector('trade-confirm');
  if (!confirmPage || !settings.confirmPageEnabled) {
    document.querySelector('.zero-delay-confirm-controls')?.remove();
    return;
  }

  // Ensure styles are injected
  injectStyles();

  // Extract order type and direction
  const confirmData = confirmPage.querySelector('trade-confirm-data');
  if (!confirmData) return;

  const orderTypeCell = Array.from(confirmData.querySelectorAll('.font-bold')).find(el =>
    el.textContent?.trim() === 'Limit' || el.textContent?.trim() === 'Market'
  );
  const isLimitOrder = orderTypeCell?.textContent?.trim() === 'Limit';

  const directionCell = Array.from(confirmData.querySelectorAll('.font-bold')).find(el =>
    el.textContent?.trim() === 'Kauf' || el.textContent?.trim() === 'Verkauf'
  );
  const isBuy = directionCell?.textContent?.trim() === 'Kauf';

  // Find quote element and extract prices
  const upperDiv = confirmPage.querySelector('.d-flex.justify-content-between.upper');
  if (!upperDiv) return;

  const quoteIndicator = upperDiv.querySelector('.quoteindicator');
  if (!quoteIndicator) return;

  const quoteText = quoteIndicator.textContent?.trim() || '';

  // Parse prices - format: "17,560 € / 17,550 €" or just "17,550 €"
  const prices = quoteText.split('/').map(p => p.trim().replace('€', '').trim());
  let currentPrice = '';

  if (prices.length === 2) {
    // Bid / Ask format
    currentPrice = isBuy ? prices[1] : prices[0]; // Ask for buy, Bid for sell
  } else {
    // Single price
    currentPrice = prices[0];
  }

  if (!currentPrice) return;

  // Convert comma to dot for calculations
  const priceStr = currentPrice.replace(',', '.');

  // Check if we already injected buttons
  let controls = confirmPage.querySelector('.zero-delay-confirm-controls') as HTMLElement;
  if (controls) return; // Already injected

  // Create container matching input page structure
  controls = document.createElement('div');
  controls.className = 'zero-delay-confirm-controls d-flex justify-content-end align-items-start mt-3 mb-3';
  controls.style.gap = '8px';

  // Header
  const header = document.createElement('div');
  header.className = 'font-bold mb-2';
  header.textContent = isLimitOrder ? 'Limit ändern:' : 'Zu Limit Order wechseln:';
  controls.appendChild(header);

  // Create price group container
  const group = document.createElement('div');
  group.className = 'zd-price-group';

  const basePrice = parseFloat(priceStr);
  const decimals = priceStr.indexOf('.') >= 0 ? priceStr.split('.')[1].length : 2;

  // Offset buttons
  if (settings.offsetButtonsEnabled) {
    const offsets = settings.customOffsets.split(';')
      .map(s => parseFloat(s.trim().replace(',', '.')))
      .filter(n => !isNaN(n));
    const uniqueOffsets = Array.from(new Set(offsets.map(Math.abs))).sort((a, b) => a - b);

    // Top Row (Positive offsets)
    if (uniqueOffsets.length > 0) {
      const topRow = document.createElement('div');
      topRow.className = 'zd-offsets-row';

      uniqueOffsets.forEach(offset => {
        const newPrice = basePrice * (1 + offset / 100);
        const newPriceStr = newPrice.toFixed(decimals);
        const label = `+${offset.toString().replace('.', ',')}%`;
        topRow.appendChild(createConfirmOffsetBtn(label, newPriceStr));
      });

      group.appendChild(topRow);
    }
  }

  // Main Button
  group.appendChild(createConfirmBtn('Kurs als Limit', priceStr));

  // Offset buttons
  if (settings.offsetButtonsEnabled) {
    const offsets = settings.customOffsets.split(';')
      .map(s => parseFloat(s.trim().replace(',', '.')))
      .filter(n => !isNaN(n));
    const uniqueOffsets = Array.from(new Set(offsets.map(Math.abs))).sort((a, b) => a - b);

    // Bottom Row (Negative offsets)
    if (uniqueOffsets.length > 0) {
      const bottomRow = document.createElement('div');
      bottomRow.className = 'zd-offsets-row';

      uniqueOffsets.forEach(offset => {
        const newPrice = basePrice * (1 - offset / 100);
        const newPriceStr = newPrice.toFixed(decimals);
        const label = `-${offset.toString().replace('.', ',')}%`;
        bottomRow.appendChild(createConfirmOffsetBtn(label, newPriceStr));
      });

      group.appendChild(bottomRow);
    }
  }

  controls.appendChild(group);

  // Market order button (only if currently limit order)
  if (isLimitOrder) {
    const marketBtn = document.createElement('button');
    marketBtn.textContent = 'Auf Market Order ändern';
    marketBtn.className = 'zd-btn mt-2';
    marketBtn.style.backgroundColor = '#dc3545';
    marketBtn.style.borderColor = '#dc3545';
    marketBtn.style.color = '#fff';
    marketBtn.style.width = '100%';

    marketBtn.onclick = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      marketBtn.blur();

      const backButton = document.querySelector('a[data-zid="order-mask-back"]') as HTMLElement;
      if (!backButton) return;

      backButton.click();
      await waitForElement('trade-create-quote', 3000);

      // Start with shorter wait, retry if needed with exponential backoff
      await new Promise(resolve => setTimeout(resolve, 100));

      let retryCount = 0;
      const maxRetries = 3;
      const retryDelays = [200, 400, 800]; // Exponential backoff for retries 2, 3, 4

      const attemptClose = () => {
        // Close all open order options
        const optionButtons = document.querySelectorAll('[data-zid="options-container"] [data-zid$="-order"]');
        optionButtons.forEach(btn => {
          const useElement = btn.querySelector('use');
          if (useElement) {
            const href = useElement.getAttribute('xlink:href') || '';
            if (href.includes('#minus')) {
              (btn as HTMLElement).click();
            }
          }
        });
      };

      // Initial attempt
      attemptClose();

      // Poll for limit input to disappear
      let pollAttempts = 0;
      const maxPollAttempts = 15;

      const checkInterval = setInterval(() => {
        pollAttempts++;
        const limitInput = document.querySelector('input[data-zid="limit-order-input"]');

        if (!limitInput) {
          // Success! Limit input is closed
          clearInterval(checkInterval);

          const checkButton = document.querySelector('web-design-system-button[data-zid="check-order"] button') as HTMLElement;
          if (checkButton) {
            checkButton.click();
          }
        } else if (pollAttempts >= maxPollAttempts) {
          // Timeout - check if we can retry
          if (retryCount < maxRetries) {
            const delay = retryDelays[retryCount];
            retryCount++;
            pollAttempts = 0;

            // Wait with exponential backoff before retry
            setTimeout(() => {
              attemptClose();
            }, delay);
          } else {
            // Failed after all retries - abort
            clearInterval(checkInterval);
            alert('Fehler: Automatischer Wechsel zur Vorbereitung einer Market Order fehlgeschlagen.\n\nBitte setzen Sie die Order manuell mit den richtigen Einstellungen fort.');
          }
        }
      }, 100);
    };

    controls.appendChild(marketBtn);
  }

  // Insert after the quote element
  upperDiv.insertAdjacentElement('afterend', controls);
};

// Helper functions for confirm page buttons
const createConfirmBtn = (label: string, price: string) => {
  const btn = document.createElement('button');
  btn.textContent = label;
  btn.className = 'zd-btn zd-btn-primary';
  btn.style.width = '100%';

  // Add tooltip
  addTooltipToButton(btn, price);

  btn.onclick = async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) tooltip.style.display = 'none';
    btn.blur();

    const backButton = document.querySelector('a[data-zid="order-mask-back"]') as HTMLElement;
    if (!backButton) return;

    backButton.click();
    await waitForElement('trade-create-quote', 3000);

    let input = document.querySelector('input[data-zid="limit-order-input"]') as HTMLInputElement;

    if (!input) {
      const limitButton = document.querySelector('div[data-zid="limit-order"]') as HTMLElement;
      if (limitButton) {
        limitButton.click();
        await waitForElement('input[data-zid="limit-order-input"]', 1000);
      }
    }

    setLimitValue(price, true);
  };

  return btn;
};

const createConfirmOffsetBtn = (label: string, price: string) => {
  const btn = document.createElement('button');
  btn.textContent = label;
  btn.className = 'zd-btn zd-offset-btn zd-btn-primary';

  // Add tooltip
  addTooltipToButton(btn, price);

  btn.onclick = async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) tooltip.style.display = 'none';
    btn.blur();

    const backButton = document.querySelector('a[data-zid="order-mask-back"]') as HTMLElement;
    if (!backButton) return;

    backButton.click();
    await waitForElement('trade-create-quote', 3000);

    let input = document.querySelector('input[data-zid="limit-order-input"]') as HTMLInputElement;

    if (!input) {
      const limitButton = document.querySelector('div[data-zid="limit-order"]') as HTMLElement;
      if (limitButton) {
        limitButton.click();
        await waitForElement('input[data-zid="limit-order-input"]', 1000);
      }
    }

    setLimitValue(price, true);
  };

  return btn;
};

const addTooltipToButton = (btn: HTMLButtonElement, price: string) => {
  btn.onmouseenter = () => {
    let tooltip = document.getElementById('zd-tooltip-el');
    if (!tooltip) {
      tooltip = document.createElement('div');
      tooltip.id = 'zd-tooltip-el';
      tooltip.className = 'zd-tooltip';
      document.body.appendChild(tooltip);
    }

    const formattedPrice = price.replace('.', ',');
    const parts = formattedPrice.split(',');

    if (parts.length === 2 && parts[1].length > 2) {
      const mainPart = parts[0];
      const firstTwoDecimals = parts[1].substring(0, 2);
      const extraDecimals = parts[1].substring(2);
      tooltip.innerHTML = `${mainPart},${firstTwoDecimals}<span style="opacity: 0.5;">${extraDecimals}</span>`;
    } else {
      tooltip.textContent = formattedPrice;
    }

    tooltip.style.display = 'block';
  };

  btn.onmousemove = (e) => {
    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) {
      tooltip.style.left = e.pageX + 'px';
      tooltip.style.top = (e.pageY - 45) + 'px';
    }
  };

  btn.onmouseleave = () => {
    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) {
      tooltip.style.display = 'none';
    }
  };
};
const confirmPage = document.querySelector('trade-confirm');
if (!confirmPage || !settings.confirmPageEnabled) {
  document.querySelector('.zero-delay-confirm-controls')?.remove();
  return;
}

// Extract order type and direction
const confirmData = confirmPage.querySelector('trade-confirm-data');
if (!confirmData) return;

const orderTypeCell = Array.from(confirmData.querySelectorAll('.font-bold')).find(el =>
  el.textContent?.trim() === 'Limit' || el.textContent?.trim() === 'Market'
);
const isLimitOrder = orderTypeCell?.textContent?.trim() === 'Limit';

const directionCell = Array.from(confirmData.querySelectorAll('.font-bold')).find(el =>
  el.textContent?.trim() === 'Kauf' || el.textContent?.trim() === 'Verkauf'
);
const isBuy = directionCell?.textContent?.trim() === 'Kauf';

// Find quote element and extract prices
const upperDiv = confirmPage.querySelector('.d-flex.justify-content-between.upper');
if (!upperDiv) return;

const quoteIndicator = upperDiv.querySelector('.quoteindicator');
if (!quoteIndicator) return;

const quoteText = quoteIndicator.textContent?.trim() || '';

// Parse prices - format: "17,560 € / 17,550 €" or just "17,550 €"
const prices = quoteText.split('/').map(p => p.trim().replace('€', '').trim());
let currentPrice = '';

if (prices.length === 2) {
  // Bid / Ask format
  currentPrice = isBuy ? prices[1] : prices[0]; // Ask for buy, Bid for sell
} else {
  // Single price
  currentPrice = prices[0];
}

if (!currentPrice) return;

// Convert comma to dot for calculations
const priceStr = currentPrice.replace(',', '.');

// Check if we already injected buttons
let controls = confirmPage.querySelector('.zero-delay-confirm-controls') as HTMLElement;
if (controls) return; // Already injected

// Create container
controls = document.createElement('div');
controls.className = 'zero-delay-confirm-controls d-flex flex-column align-items-end mt-3 mb-3';
controls.style.gap = '8px';

// Header
const header = document.createElement('div');
header.className = 'font-bold';
header.textContent = isLimitOrder ? 'Limit ändern:' : 'Zu Limit Order wechseln:';
controls.appendChild(header);

// Button container
const buttonContainer = document.createElement('div');
buttonContainer.className = 'd-flex';
buttonContainer.style.gap = '8px';
buttonContainer.style.flexWrap = 'wrap';
buttonContainer.style.justifyContent = 'flex-end';

// Helper to create limit button
const createLimitBtn = (label: string, price: string) => {
  const btn = document.createElement('button');
  btn.textContent = label;
  btn.className = 'zd-btn zd-btn-primary'; // Always primary on confirm page

  // Add tooltip (inline implementation)
  btn.onmouseenter = () => {
    let tooltip = document.getElementById('zd-tooltip-el');
    if (!tooltip) {
      tooltip = document.createElement('div');
      tooltip.id = 'zd-tooltip-el';
      tooltip.className = 'zd-tooltip';
      document.body.appendChild(tooltip);
    }

    // Format price with dimmed extra decimals
    const formattedPrice = price.replace('.', ',');
    const parts = formattedPrice.split(',');

    if (parts.length === 2 && parts[1].length > 2) {
      const mainPart = parts[0];
      const firstTwoDecimals = parts[1].substring(0, 2);
      const extraDecimals = parts[1].substring(2);
      tooltip.innerHTML = `${mainPart},${firstTwoDecimals}<span style="opacity: 0.5;">${extraDecimals}</span>`;
    } else {
      tooltip.textContent = formattedPrice;
    }

    tooltip.style.display = 'block';
  };

  btn.onmousemove = (e) => {
    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) {
      tooltip.style.left = e.pageX + 'px';
      tooltip.style.top = (e.pageY - 45) + 'px';
    }
  };

  btn.onmouseleave = () => {
    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) {
      tooltip.style.display = 'none';
    }
  };

  btn.onclick = async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const tooltip = document.getElementById('zd-tooltip-el');
    if (tooltip) tooltip.style.display = 'none';
    btn.blur();

    // Navigate back to order entry
    const backButton = document.querySelector('a[data-zid="order-mask-back"]') as HTMLElement;
    if (!backButton) {
      console.warn('ZeroDelay: Back button not found');
      return;
    }

    backButton.click();

    // Wait for order entry page
    await waitForElement('trade-create-quote', 3000);

    // Check if limit input is already visible
    let input = document.querySelector('input[data-zid="limit-order-input"]') as HTMLInputElement;

    if (!input) {
      // Limit input not visible, need to open it
      const limitButton = document.querySelector('div[data-zid="limit-order"]') as HTMLElement;
      if (limitButton) {
        limitButton.click();
        // Wait for input to appear
        await waitForElement('input[data-zid="limit-order-input"]', 1000);
      }
    }

    // Set limit value with auto-check
    setLimitValue(price, true);
  };

  return btn;
};

// Main button
buttonContainer.appendChild(createLimitBtn('Kurs als Limit', priceStr));

// Offset buttons
if (settings.offsetButtonsEnabled) {
  const offsets = settings.customOffsets.split(';')
    .map(s => parseFloat(s.trim().replace(',', '.')))
    .filter(n => !isNaN(n));
  const uniqueOffsets = Array.from(new Set(offsets.map(Math.abs))).sort((a, b) => a - b);

  const basePrice = parseFloat(priceStr);
  const decimals = priceStr.indexOf('.') >= 0 ? priceStr.split('.')[1].length : 2;

  uniqueOffsets.forEach(offset => {
    [true, false].forEach(isPositive => {
      const finalOffset = isPositive ? offset : -offset;
      const newPrice = basePrice * (1 + finalOffset / 100);
      const newPriceStr = newPrice.toFixed(decimals);
      const sign = isPositive ? '+' : '-';
      const label = `${sign}${offset.toString().replace('.', ',')}%`;

      buttonContainer.appendChild(createLimitBtn(label, newPriceStr));
    });
  });
}

controls.appendChild(buttonContainer);

// Market order button (only if currently limit order)
if (isLimitOrder) {
  const marketBtn = document.createElement('button');
  marketBtn.textContent = 'Auf Market Order ändern';
  marketBtn.className = 'zd-btn mt-2';
  marketBtn.style.fontSize = '11px';
  marketBtn.style.padding = '4px 12px';
  marketBtn.style.backgroundColor = '#dc3545';
  marketBtn.style.borderColor = '#dc3545';
  marketBtn.style.color = '#fff';

  marketBtn.onclick = (e) => handleMarketButtonClick(e, marketBtn);

  controls.appendChild(marketBtn);
}

// Insert after the quote element
upperDiv.insertAdjacentElement('afterend', controls);
};

const processTimestamps = () => {
  if (!settings.isActive) {
    removeAllIndicators();
    return;
  }

  if (settings.latencyMonitorEnabled) {
    const timeNodes = document.querySelectorAll('span[data-zid="quote-time"]');
    timeNodes.forEach((node) => {
      const timeStr = node.textContent?.trim();
      if (!timeStr) return;

      const quoteDate = parseTime(timeStr);
      if (!quoteDate) return;

      const now = new Date();
      const diffMs = now.getTime() - quoteDate.getTime();
      const diffSec = Math.floor(diffMs / 1000);

      let stateClass = 'latency-good';
      if (diffSec >= settings.criticalThreshold) {
        stateClass = 'latency-critical';
      } else if (diffSec >= settings.warningThreshold) {
        stateClass = 'latency-warning';
      }

      const displayTime = diffSec > 60
        ? `${Math.floor(diffSec / 60)}m ${diffSec % 60}s`
        : `${diffSec}s`;

      let indicator = node.parentElement?.querySelector('.latency-indicator') as HTMLElement;
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'latency-indicator';
        indicator.style.marginLeft = '8px';
        node.parentElement?.appendChild(indicator);
      }

      indicator.classList.remove('latency-good', 'latency-warning', 'latency-critical');
      indicator.classList.add(stateClass);
      indicator.innerText = `(${displayTime})`;

      updatePerformanceIndicator({ stateClass, displayTime: `(${displayTime})` });
    });
  } else {
    removeAllIndicators();
  }

  injectLimitButtons();
  injectLimitAdjuster();
  injectConfirmPageButtons();
};

// Run every second
setInterval(processTimestamps, 1000);

// Run immediately on load
processTimestamps();